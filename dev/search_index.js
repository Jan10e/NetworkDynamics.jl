var documenterSearchIndex = {"docs":
[{"location":"StaticEdges/#Static-edges-1","page":"Static edges","title":"Static edges","text":"","category":"section"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"OUTDATED","category":"page"},{"location":"StaticEdges/#Scalar-variables-1","page":"Static edges","title":"Scalar variables","text":"","category":"section"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"We will first look into the case where there is only a scalar variable on each vertex. A dynamical network with static edges (static meaning that the current on an edge depends solely on the values on the vertices it connects) is created via the ndODEStatic_scalar function:","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"ssl = nd_ODE_Static_scalar(vertices!, edges!, g)","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"The functions vertices! and edges! are of the form:","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"vertices![n](dv[n],v[n],e_s[n],e_t[n],p,t)\nedges![m](e[m],v_s,v_t,p,t)  ","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"Specifically, the given variables are:","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"e_s[n] = [e[m] if s[m] == n for m in 1:length(edges!)]\ne_t[n] = [e[m] if t[m] == n for m in 1:length(edges!)]\nv_s= v[s[m]]\nv_t= v[t[m]]","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"The vectors s and t contain the information about the source and target of each edge, i.e. s[1] == 2 -> The source of edge 1 is vertex 2. The function creates these vectors from the given graph, they can be accessed via the calling syntax ssl.se or ssl.te. The vectors es[n] and et[n] are containing the in- and outgoing edge values (or currents) of vertex n in the form of an array. Thus, one would classically sum over these in vertices!, but one is not restricted on doing this.","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"For example, a system of equations describing a simple diffusive network would be:","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"using LightGraphs\ng= barabasi_albert(10,5)\nvertices! = [(dv,v,l_s,l_t,p,t) -> dv .= sum(e_s) .- sum(e_t) for vertex in vertices(g)]\nedges! = [(e,v_s,v_t,p,t) -> e .= v_s .- v_t for edge in edges(g)]","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"Here, the diffusiveness lies within the edges! function. It states that there is only a current between two vertices if these vertices have a non-equal value. This current then ultimatively leads to an equilibrium in which the value on any connected vertex is equal.","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"Note that one should (for performance reasons) and actually needs to put a dot before the mathematical operators. This is due to the use of views in the internals of the ndODEStatic_scalar function.","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"We finally want to solve the defined diffusive system. This we do by using the well-known package DifferentialEquations.jl (see here). We also need to specify a set of initial values x0 as well as a time interval t for which we are solving the problem:","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"using DifferentialEquations\nusing Plots\nx0 = rand(10)\nt = (0.,2.)\nssl = nd_ODE_Static_scalar(vertices!,edges!,g)\nssl_prob = ODEProblem(ssl,x0,t)\nsol = solve(ssl_prob)\nplot(sol, legend = false)","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"(Image: )","category":"page"},{"location":"StaticEdges/#","page":"Static edges","title":"Static edges","text":"As one would expect in a diffusive network, the values on the vertices converge.","category":"page"},{"location":"Library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"Library/#Public-Interface-1","page":"Library","title":"Public Interface","text":"","category":"section"},{"location":"Library/#","page":"Library","title":"Library","text":"The following functions are designed for public use","category":"page"},{"location":"Library/#","page":"Library","title":"Library","text":"","category":"page"},{"location":"Library/#","page":"Library","title":"Library","text":"network_dynamics\nStaticVertex\nODEVertex\nStaticEdge\nODEEdge","category":"page"},{"location":"Library/#NetworkDynamics.network_dynamics","page":"Library","title":"NetworkDynamics.network_dynamics","text":"network_dynamics(vertices!, edges!, g)\n\nAssembles the the dynamical equations of the network problem into an ODEFunction compatible with the DifferentialEquations.jl solvers. Takes as arguments an array of VertexFunctions vertices!, an array of EdgeFunctions edges! and a LightGraph.jl object g.\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.NDFunctions.StaticVertex","page":"Library","title":"NetworkDynamics.NDFunctions.StaticVertex","text":"StaticVertex(f!, dim, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a static node and has to respect the following calling syntax\n\nf!(v, e_s, e_t, p, t) -> nothing\n\nHere  v, p and t are the usual arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively.\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.NDFunctions.ODEVertex","page":"Library","title":"NetworkDynamics.NDFunctions.ODEVertex","text":"ODEVertex(f!, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a dynamic node and has to respect the following calling syntax\n\nf!(dv, v, e_s, e_t, p, t) -> nothing\n\nHere dv, v, p and t are the usual ODE arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively.\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * dv = f! will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.NDFunctions.StaticEdge","page":"Library","title":"NetworkDynamics.NDFunctions.StaticEdge","text":"StaticEdge(f!, dim, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a static edge and has to respect the following calling syntax\n\nf!(e, v_s, v_t, p, t) -> nothing\n\nHere  e, p and t are the usual arguments, while v_s and v_d are arrays containing the vertices which are the source and destination of the described edge.\n\ndim is the number of independent variables in the edge equations and sym is an array of symbols for these variables.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.NDFunctions.ODEEdge","page":"Library","title":"NetworkDynamics.NDFunctions.ODEEdge","text":"ODEEdge(f!, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a dynamic edge and has to respect the following calling syntax\n\nf!(de, e, v_s, v_t, p, t) -> nothing\n\nHere  de, e, p and t are the usual arguments, while v_s and v_d are arrays containing the vertices which are the source and destination of the described edge.\n\ndim is the number of independent variables in the edge equations and sym is an array of symbols for these variables. For more details see the documentation. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * de = f! will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"DynamicEdges/#Dynamic-edges-1","page":"Dynamic edges","title":"Dynamic edges","text":"","category":"section"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"OUTDATED","category":"page"},{"location":"DynamicEdges/#Scalar-variables-1","page":"Dynamic edges","title":"Scalar variables","text":"","category":"section"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"In general, currents do not solely depend on the vertex values they are connecting, but rather depend on its own value in some sort. For the case of scalar variables, we may use the function ndODEODE_scalar:","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"sdl = nd_ODE_ODE_scalar(vertices!,edges!,g)","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"The function arguments are now of the following form:","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"vertices![n](dv[n],v[n],e_s[n],e_t[n],p,t)\nedges![m](de[m],e[m],v_s,v_t,p,t)","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"Compared to the static edges case with scalar variables, the vertices! function keeps its structure whereas the edges! function gets the new argument de[m]. This de[m] is the derivative of the edge value of edge m. Let's look at a simple example: A system with dynamic edges which decay to the usual diffusive system:","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"vertices! = [(dv,v,l_s,l_t,p,t) -> dv .= sum(e_s) .- sum(e_t) for vertex in vertices(g)]\nedges! = [(de,e,v_s,v_t,p,t) -> de .= 1000*(v_s .- v_t .- e) for edge in edges(g)]","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"The change compared to the example for the static case should be clear; the factor of 1000 is just accelerating the decay. Again, we can quite simply solve this system. One has to be aware though that now one needs initial values for the vertices and the edges! These are given in the order x0 = [vertex1,vertex2,...,edge1,edge2,...]:","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"g = barabasi_albert(10,5) #generates a graph with 10 vertices and 25 edges\nx0 = rand(10 + 25)\nt = (0.,2.)\nsdl = nd_ODE_ODE_scalar(vertices!,edges!,g)\nsdl_prob = ODEProblem(sdl,x0,t)\nsol = solve(sdl_prob)\nplot(sol, legend = false , vars = 1:10)","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"(Hier sollte ein Bild sein)","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"We see that the plot looks pretty much the same as for the static edges case. That is, because we included the factor of 1000 in the edges! function. Note that we added the argument vars to the plot function, this gives us solely the first 10 arguments of x which are the vertices. One could also get just the edge values by writing vars = 11:35 if one wishes.","category":"page"},{"location":"DynamicEdges/#Vector-variables-1","page":"Dynamic edges","title":"Vector variables","text":"","category":"section"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"The step here is not a hard one, if one read through the previous Vector variables section. We can treat a system of vector variables with dynamic edges with the function dynamic_edges:","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"dl = dynamic_edges(vertices!,edges!,g,dim_v,dim_e)","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"One has to apply the same change to the vertices! function as for the static_edges function. Otherwise, everything should be clear. For the example, we take the decaying dynamic edges and just make two independent networks as for the Static edges:","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"dim_v = 2 * ones(Int32, length(vertices!))\ndim_e = 2 * ones(Int32, length(edges!))\ng = barabasi_albert(10,5)\n\nfunction vertex!(dv, v, e_s, e_d, p, t)\n    dv .= 0\n    for e in e_s\n        dv .-= e\n    end\n    for e in e_d\n        dv .+= e\n    end\n    nothing\nend\n\nvertices! = [vertex! for vertex in vertices(g)]\nedges! = [(de,e,v_s,v_t,p,t) -> de .= 1000*(v_s .- v_t .- e) for edge in edges(g)]\n\ndl = dynamic_edges(vertices!,edges!,g,dim_v,dim_e)\n\nx0 = rand(10 + 10 + 25 + 25)\nt= (0.,2.)\ndl_prob = ODEProblem(dl,x0,t)\nsol= solve(dl_prob)\nplot(sol, legend = false, vars = 1:20)","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"(Image: )","category":"page"},{"location":"DynamicEdges/#","page":"Dynamic edges","title":"Dynamic edges","text":"We get the same pattern as for the scalar case, just twice.","category":"page"},{"location":"Examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/#","page":"Examples","title":"Examples","text":"To solve the defined system, we further need an array with initial values x0 as well as a time span tspan in which we solve the problem:","category":"page"},{"location":"Examples/#","page":"Examples","title":"Examples","text":"\nusing OrdinaryDiffEq\n\nx0 = rand(10 + 25) #10 for the vertices and 25 for the edges\ntspan = (0.,2.)\n\nprob = ODEProblem(nd,x0,tspan)\nsol = solve(prob)\n\nusing Plots\nplot(sol, legend = false, vars = 1:10) # vars gives us x[1:10] in the plot","category":"page"},{"location":"Examples/#","page":"Examples","title":"Examples","text":"The Plot shows the classic diffusive behaviour.","category":"page"},{"location":"Examples/#Mass-Matrix-OUTDATED-1","page":"Examples","title":"Mass Matrix - OUTDATED","text":"","category":"section"},{"location":"Examples/#","page":"Examples","title":"Examples","text":"One thing one has to know when working with mass matrices is best described via an example, let's consider the same problem as before with solely changed edge and vertex:","category":"page"},{"location":"Examples/#","page":"Examples","title":"Examples","text":"vertex = ODEVertex(vertexfunction!, 2, [2 1; -1 1], nothing)\nedge = ODEEdge(edgefunction!, 2)","category":"page"},{"location":"Examples/#","page":"Examples","title":"Examples","text":"We now have two dimensional vertex and edge variables, we additionally added a mass matrix for every vertex. The Constructor builds one big mass matrix from all the given ones. If one now wants to solve the problem, one has to specify the solving algorithm for the solver as the default solver can't handle mass matrices. The DAE solvers are fit for these kind of problems. One has to be especially aware of putting the variable autodiff inside the algorithm to false, hence one has to write the solver like this:","category":"page"},{"location":"Examples/#","page":"Examples","title":"Examples","text":"sol = solve(prob, Rodas4(autodiff = false)) # Rodas4 is just an exemplary DAE solving algorithm, there are many more.#","category":"page"},{"location":"Examples/#","page":"Examples","title":"Examples","text":"With that, everything works just fine. One has to put autodiff to false, because the structure of the lastly given equations is not of the standard form that the DAE solvers can handle just like that.","category":"page"},{"location":"getting_started_with_network_dynamics/#Getting-started-with-NetworkDynamics-a-simple-diffusion-1","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"This introductory example explains the use of the basic types and constructors in NetworkDynamics.jl by modeling a simple diffusion on an undirected network.","category":"page"},{"location":"getting_started_with_network_dynamics/#Theoretical-background-1","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Theoretical background","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"Diffusion processes are relevant for phenomena as diverse as heat conduction, electrical currents, and random walks. Generally speaking they describe the tendency of systems to evolve towards a state of equally distributed heat, charge or concentration. In such system the local temperature (or concentration) changes according to its difference with its neighborhood, i.e. the temperature gradient.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"Let g be a graph with N nodes and adjacency matrix A. Let v = (v_1 dots v_n) be a vector of (abstract) temperatures or concentrations at each node i = 1 dots N. Then the rate of change of state v_i is described by its difference with its neighbors and we obtain the following ordinary differential equation","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"dot v_i = - sum_i=1^N A_ij (v_i - v_j)","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j it will decrease along that edge.","category":"page"},{"location":"getting_started_with_network_dynamics/#Modeling-diffusion-in-NetworkDynamics.jl-1","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Modeling diffusion in NetworkDynamics.jl","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"From the above considerations we see that in this model the nodes do not have any internal dynamics - if a node was disconnected from the rest of the network its state would never change, since then A_ij = 0  forall j and hence dot v_i = 0. This means that the evolution of a node depends only on the interaction with its neighbors. In NetworkDynamics.jl interactions with neighbors are described by equations for the edges.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"function diffusionedge!(e, v_s, v_d, p, t)\n    # usually e, v_s, v_d are arrays, hence we use the broadcasting operator .\n    e .= v_s - v_d\n    nothing\nend","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The function diffusionedge! takes as inputs the current state of the edge e, its source vertex v_s, its destination vertex v_d, a vector of parameters p and the time t. In order to comply with the syntax of NetworkDynamics.jl we always have to define functions for static edges with exactly these arguments, eventhough we do not need p and t for the diffusion example.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"diffusionedge! is called a mutating function, since it modifies (or mutates) one of its inputs, namely the edge state e. As a convention in julia names of mutating functions end with an !. The use of mutating functions reduces allocations and thereby speeds up computations. After the function call the edge's value e equals the difference between its source and its destination vertex (i.e. the discrete gradient along that edge).","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The contributions of the different edges are then summed up in each vertex.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"function diffusionvertex!(dv, v, e_s, e_d, p, t)\n    # usually v, e_s, e_d are arrays, hence we use the broadcasting operator .\n    dv .= 0.\n    # edges for which v is the source\n    for e in e_s\n        dv .-= e\n    end\n    # edges for which v is the destination\n    for e in e_d\n        dv .+= e\n    end\n    nothing\nend    ","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"Just like above the input arguments v, e_s, e_d, p, t are mandatory for the syntax of vertex functions. The additional input dv corresponding to the derivative of the vertex' state is mandatory for vertices described by ordinary differential equations.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"Something unexpected happens in the for-loops: The contributions of the connecting edges are subtracted or added depending on v being the source or the destination of an edge. However we are modeling diffusion on an undirected network, hence the concepts of source and destination are not defined!","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The reason for this syntax is found in the LightGraphs.jl package on which NetworkDynamics.jl is based. LightGraphs.jl attaches a direction to every edge of a graph and ignores the directionality if the graph is undirected. A user working only with the functionality provided by LightGraphs.jl won't neccessarily notice this design decision. However since NetworkDynamics.jl is interfacing directly to the underlying graph objects, we have to keep in mind that every edge has an abstract direction and thus a source and a destination.","category":"page"},{"location":"getting_started_with_network_dynamics/#How-to-deal-with-abstract-edge-directions-in-undirected-graphs-1","page":"Getting started with NetworkDynamics - a simple diffusion","title":"How to deal with abstract edge directions in undirected graphs","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"In the diffusion example, assume node i is connected to node j by an undirected edge.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"Case: i -> j","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"If the connection is realized by an abstract edge pointing from i to j then the edge value will be v_i - v_j. Hence we have to subtract this term from dv.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"Case: j -> i","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"In this case the edge value is v_j - v_i. Of course that's just -(v_i - v_j) and can be directly added to dv.","category":"page"},{"location":"getting_started_with_network_dynamics/#Caveat:-Symmetric-and-asymmetric-coupling-terms-1","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Caveat: Symmetric and asymmetric coupling terms","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The coupling term g(i j) = v_i - v_j is anti-symmetric, that is g(ij) = - g(ji) and hence multiplying some edge values with -1 restores the behaviour of undirected edges. The same property holds for other important coupling terms like g(ij) = sin(v_i - v_j). On the other hand, if the coupling term happens to be symmetric, i.e. g(ij) = g(ji) we don't have to worry about the abstract direction at all.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"However, some coupling terms are neither symmetric nor anti-symmetric like the chemical coupling between neurons. In this case it is a viable strategy to double the number of edge variables, compute both outcomes and use only one depending on the abstract direction of the edge. For more details have a look at the example on chemical coupling.","category":"page"},{"location":"getting_started_with_network_dynamics/#Constructing-the-network-1","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Constructing the network","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"With the preliminaries out of the way, it only takes a few steps to assemble the network dynamics.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"using LightGraphs\n\nN = 20 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The Barabási–Albert model generates a scale-free random graph.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"using NetworkDynamics\n\nnd_diffusion_vertex = ODEVertex(f! = diffusionvertex!, dim = 1)\nnd_diffusion_edge = StaticEdge(f! = diffusionedge!, dim = 1)\n\nnd = network_dynamics(nd_diffusion_vertex, nd_diffusion_edge, g)","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"ODEVertex and StaticEdge are functions wrappers that equip the functions we defined above with additional information like dim and return objects of type VertexFunction and EdgeFunction. Then the key constructor network_dynamics combines them with the topological information contained in the graph g and returns an ODEFunction compatible with the solvers of DifferentialEquations.jl. The keyword dim specifies the number of variables at each edge or node.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"using OrdinaryDiffEq\n\nx0 = randn(N) # random initial conditions\node_prob = ODEProblem(nd, x0, (0., 4.))\nsol = solve(ode_prob, Tsit5());","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"We are solving the diffusion problem on the time interval 0 4 with the Tsit5() algorithm, which is recommended  by the authors of DifferentialEquations.jl for most non-stiff problems.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"using Plots\nplot(sol, vars = syms_containing(nd, \"v\"))","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"(Image: svg)","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The plotting is straightforward. The vars keyword allows us to pass a list of indices or symbols specifiying the variables we want to plot. Symbols can be thought of as names given to the interal variables of an ODEFunction, much like the variables x or phi in mathematical notation. The default symbol for vertex variables is v, however we are free to specify other symbols by passing them to the ODEVertex constructor.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"syms_containing is a helper function that returns all symbols of an ODEProblem containg a specific string (or symbol).","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"To illustrate a very simple multi-dimensional case, in the following we simulate two independent diffusions on an identical network. The first uses the symbol x and is started with initial conditions drawn from the standard normal distribution N(01), the second uses the symbol ϕ with squared standard normal inital conditions.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The symbols have to be passed with the keyword sym to ODEVertex.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"N = 10 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\n# We will have two indepent diffusions on the network, hence dim = 2\nnd_diffusion_vertex_2 = ODEVertex(f! = diffusionvertex!, dim = 2, sym = [:x, :ϕ])\nnd_diffusion_edge_2 = StaticEdge(f! = diffusionedge!, dim = 2)\nnd_2 = network_dynamics(nd_diffusion_vertex_2, nd_diffusion_edge_2, g)\n\nx0_2 = vec(transpose([randn(N) randn(N).^2])) # x ~ N(0,1); ϕ ~ x^2\node_prob_2 = ODEProblem(nd_2, x0_2, (0., 3.))\nsol_2 = solve(ode_prob_2, Tsit5());\n\n\n# Try plotting the variables ϕ_i yourself. [Type \\phi and press TAB]\nplot(sol_2, vars = syms_containing(nd_2, \"x\"))","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"(Image: svg)","category":"page"},{"location":"getting_started_with_network_dynamics/#Appendix:-The-network-Laplacian-L-1","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Appendix: The network Laplacian L","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"The diffusion equation on a network can be rewritten as","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"dot v_i  = d_i v_i - sum_i=1^N A_ij v_j = d_i v_i - e_i^T A v          ","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"where d_i is the degree of node i and e_i^T is the i-th standard basis vector. Introducing the diagonal matrix D that has the degree of node i in its i-th row and the Laplacian matrix L = D - A we arrive at","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"dot v = e_i^T(D - A) v","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"and finally","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"dot v = L v","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started with NetworkDynamics - a simple diffusion","title":"Getting started with NetworkDynamics - a simple diffusion","text":"This is a linear system of ODEs and its solution is a matrix exponential. To study the asymptotic behaviour of the system it suffices to analyze the eigenspectrum of L. For this reason L is an important construction in network science.","category":"page"},{"location":"#NetworkDynamics-1","page":"General","title":"NetworkDynamics","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"A package for working with dynamical systems on complex networks. NetworkDynamics.jl provides an interface between LightGraphs.jl and DifferentialEquations.jl. It allows to define several types of dynamic and static nodes and edges and to link them up in order to create complex network dynamics.","category":"page"},{"location":"#","page":"General","title":"General","text":"At the moment the behaviour of a node or an edge can be described by algebraic equations or by ordinary differential equations (ODE). Support for stochastic differential equations (SDE) and delay differential equations (DDE) will be added in future releases.","category":"page"},{"location":"#Installation-1","page":"General","title":"Installation","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Installation is straightforward with Julia's package manager.","category":"page"},{"location":"#","page":"General","title":"General","text":"(v1.3) pkg> add NetworkDynamics","category":"page"},{"location":"#PowerDynamics-1","page":"General","title":"PowerDynamics","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"PowerDynamics.jl is an open-source framework for dynamic power grid modeling and analysis build on top of NetworkDynamics.jl.","category":"page"},{"location":"#Overview-1","page":"General","title":"Overview","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"The key construction is the function network_dynamics that takes in two arrays of functions describing the local dynamics on the edges and nodes of a graph g, and returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"#","page":"General","title":"General","text":"nd = network_dynamics(vertices!::Array{VertexFunction},  edges!::Array{EdgeFunction}, g)\nnd(dx, x, p, t)","category":"page"},{"location":"#","page":"General","title":"General","text":"This page is still in development. :)","category":"page"},{"location":"BasicConstructors/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The key constructor network_dynamics assembles the dynamics of the whole network from functions for the single vertices and edges of the graph g. Since the equations describing the local dynamics may differ strongly from each other, the types VertexFunction and EdgeFunction are introduced. They provide a unifying interface between different classes of nodes and edges. Both have several subtypes that account for the different classes of equations that may represent the local dynamics. At the moment algebraic (static) equations and ordinary differential equations (ODEs) are supported:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# VertexFunctions\nStaticVertex(vertexfunction!, dimension, symbol)\nODEVertex(vertexfunction!, dimension, mass_matrix, symbol)\n\n# EdgeFunctions\nStaticEdge(edgefunction!, dimension, symbol)\nODEEdge(edgefunction!, dimension, mass_matrix, symbol)","category":"page"},{"location":"BasicConstructors/#VertexFunctions-1","page":"Functions","title":"VertexFunctions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Given a set of (algebraic or differential) equations describing a node or an edge the first step is to turn them into a mutating function vertexfunction!. Depending on the class of the function vertexfunction!, the constructors StaticVertex or ODEVertex are called in order to turn vertexfunction! into a VertexFunction object compatible with network_dynamics.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Since in general the state of a vertex depends on the vertex value itself as well as on the in- and outgoing edges, the function vertexfunction! has to respect one of the following calling syntaxes.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# For static nodes\nfunction vertexfunction!(v, e_s, e_d, p, t) end\n# For dynamic nodes\nfunction vertexfunction!(dv, v, e_s, e_d, p, t) end","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Here dv, v, p and t are the usual ODE arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively. The typical case of diffusive coupling on a directed graph could be described as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"function vertex!(dv, v, e_s, e_d, p, t)\n    dv .= 0.\n    for e in e_s\n        dv .-= e\n    end\n    for e in e_d\n        dv .+= e\n    end\n    nothing\nend","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"warning: Warning\nThe arguments e_s and e_d are obligatory even if the graph is undirected and no distinction between source and destination can be made. This is necessary since LightGraphs.jl implements an undirected graph in the same way as a directed graphs, but ignores the directionality information. Therefore some care has to be taken when dealing with assymetric coupling terms. A detailed example can be found  in the Examples section.","category":"page"},{"location":"BasicConstructors/#[StaticVertex](@ref)-1","page":"Functions","title":"StaticVertex","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"If a vertex is described by an algebraic equation  vertexfunction!(v, e_s, e_d, p, t), i.e. dv = 0 the VertexFunction is constructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"StaticVertex(vertexfunction!, dim, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Here, dim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. For example, if a node models a constant input I = p, then dim = 1 and sym = [:I]. For more details on the use of symbols, check out the Examples section or the Julia documentation. The use of symbols makes it easier to later fish out the interesting variables one wants to look at.","category":"page"},{"location":"BasicConstructors/#[ODEVertex](@ref)-1","page":"Functions","title":"ODEVertex","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"If a vertex has local dynamics vertexfunction!(dv, v, e_s, e_d, p, t) described by an ODE the VertexFunction is contructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEVertex(vertexfunction!, dim, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"As above, dim is the number of independent variables in the vertex equations and sym corresponds to the symbols of these variables.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * dv = vertexfunction! will be solved.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"One may also call ODEVertex with keyword arguments, omitting optional arguments:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEVertex(f! = vertexfunction!, dim = dim)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The function then defaults to using the identity as mass matrix and [:v for i in 1:dimension] as symbols.","category":"page"},{"location":"BasicConstructors/#EdgeFunctions-1","page":"Functions","title":"EdgeFunctions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Similar to the case of vertices, an edge is described by mutating function edgefunction!. At the moment the constructors StaticEdge and ODEEdge are available. edgefunction! has to respect one of the following syntaxes:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# For static edges\nfunction edgefunction!(e, v_s, v_d, p, t) end\n# For dynamics edges\nfunction edgefunction!(de, e, v_s, v_d, p, t) end","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Just like above, de, e, p and t are the usual ODE arguments, while v_s and v_d are the source and destination vertices respectively.","category":"page"},{"location":"BasicConstructors/#[StaticEdge](@ref)-1","page":"Functions","title":"StaticEdge","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Static here means, that the edge value described by edgefunction! only depends on the values of the vertices the edge connects to and that no derivative of the edge's internal state is involved. One very simple and natural example is a diffusive edge:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"edgefunction! = (e, v_s, v_d, p, t) -> e .= v_s .- v_d","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"In this case the EdgeFunction is constructed by","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"StaticEdge(edgefunction!, dim, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The keywords are the same as for the vertices.","category":"page"},{"location":"BasicConstructors/#[ODEEdge](@ref)-1","page":"Functions","title":"ODEEdge","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"For problems where edgefunction! describes the differential of an edge value, we use the ODEEdge function. An example for such a system is given by:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"edgefunction! = (de, e, v_s, v_d, p, t) -> de .= 1000 * (v_s .- v_d .- e)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The EdgeFunction object is constructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEEdge(edgefunction!, dim, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The keywords are the same as for the vertices. For ODEEdge the same simplified construction rules apply when keyword arguments are used.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEEdge(f! = edgefunction!, dim = n)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"In this case the function defaults to using the identity as mass matrix and [:e for in 1:dimension] as symbols.","category":"page"},{"location":"BasicConstructors/#Constructor-1","page":"Functions","title":"Constructor","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The key constructor is the function network_dynamics that takes in two arrays of EdgeFunctions and VertexFunctions describing the local dynamics on the edges and nodes of a graph g, given as a LightGraphs.jl object. It returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertices!::Array{VertexFunction},\n                      edges!::Array{EdgeFunction}, g)\nnd(dx, x, p, t)","category":"page"},{"location":"BasicConstructors/#Example-1","page":"Functions","title":"Example","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Let's look at an example. First we define our graph as well as the differential systems connected to its vertices and edges:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"using NetworkDynamics, LightGraphs\n\ng = erdos_renyi(10, 25) # random graph with 10 vertices and 25 edges\n\nfunction vertexfunction!(dv, v, e_s, e_d, p, t)\n  dv .= 0\n  for e in e_s\n    dv .-= e\n  end\n  for e in e_d\n    dv .+= e\n  end\nend\n\nfunction edgefunction!(de, e, v_s, v_d, p, t)\n     de .= 1000 .*(v_s .- v_d .- e)\n     nothing\nend\n\nvertex = ODEVertex(f! = vertexfunction!, dim = 1)\nvertexarr = [vertex for v in vertices(g)]\n\nedge = ODEEdge(f! = edgefunction!, dim = 1)\nedgearr = [edge for e in edges(g)]\n\nnd = network_dynamics(vertexarr, edgearr, g)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Now we have an ODEFunction nd that can be solved with the tools provided by DifferentialEquations.jl.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"For more details see the Examples section.","category":"page"}]
}
