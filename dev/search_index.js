var documenterSearchIndex = {"docs":
[{"location":"Multithreading/#Multi-Threading-1","page":"Multi-Threading","title":"Multi-Threading","text":"","category":"section"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"Since version 0.3.0 multi-threading via the Threads.@threads macro is possible. This allows julia to integrate different nodes and edges in different threads, and can lead to significant performance gains on parallel architectures. To enable multi-threading call network_dynamics with the keyword argument parallel=true.","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"network_dynamics(vertices!, edges!, graph, parallel=true)","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"In order for this to take effect, multiple threads have to be available. This is achieved by setting the environment variable JULIA_NUM_THREADS before starting Julia.  To start Julia from a bash shell and with 4 threads use:","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"$ env JULIA_NUM_THREADS=4 julia","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"If you are using Juno for the Atom text editor JULIA_NUM_THREADS is set to the number of physical cores of your processor by default. This is also the number of threads we recommend to use.","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"note: Note\nThe thread handling causes an overhead in the order of 20 Î¼s per call to the ODE function which might impair performance on small networks (<100 nodes) or on single core machines. In theses cases network_dynamics can be called without any additional arguments, since parallel defaults to false.","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"For more information on setting environment varibales see the Julia documentation.","category":"page"},{"location":"parameters/#Parameter-handling-1","page":"Parameter handling","title":"Parameter handling","text":"","category":"section"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Let nd! be an ODEFunction returned by network_dynamics, e.g.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"nd! = network_dynamics(vertices!, edges!, graph)","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"then the behaviour of nd! has the signature (dx, x, t, p) and its behaviour changes with the type of parameters p being passed.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"When p is an Array, a Dict, a struct... then the entire object is passed to each VertexFunction and EdgeFunction.\nWhen p = (p_v, p_e) is a Tuple of two values, then the first value will be passed to all vertices and the second to all edges.\nIf p = (p_v_arr, p_e_arr) is a Tuple of two Arrays with lengths corresponding to the number of nodes and number of edges respectively, then the edges or nodes receive only the parameter with the corresponding index.\nIf all nodes and/or edges have no internal parameters the value nothing may be passed. Using nothing instead of dummy parameters is usually faster, since then less data are copied.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Another option for specifying heterogeneous parameters is to make each VertexFunction a callable struct with the parameters hardcoded as fields. This approach is used in PowerDynamics.jl. However it provides considerably less flexibility and interoperability with other packages.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"For its greater speed and flexibility in modeling we recommend to use the tuple syntax.","category":"page"},{"location":"parameters/#Compatability-with-DiffEqFlux-1","page":"Parameter handling","title":"Compatability with DiffEqFlux","text":"","category":"section"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Most of the sensitivity algorithms that DiffEqFlux makes use of assume that the parameters p are a subtype of AbstractArray. Therefore they are not compatible with the tuple syntax.TrackerAdjoint does not have these limitations but works best on out-of-place problems. Unfortunately, network_dynamics returns an ODEProblem that is in-place (mutating its inputs) leading to slow performance with Tracker.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"However, wrapping the function in such a way that it accepts arrays of parameters that are later pasted into the tuple syntax sidesteps these issues and enables the use of adjoint methods. Depending on the use case such a wrapper might look like this:","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"function nd_wrapper!(dx, x, p, t)\n  nd!(dx, x, (p, nothing), t)\nend","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"nd_wrapper! should now work with BacksolveAdjoint and InterpolatingAdjoint. At the moment we recommend this way for combining NetworDynamics and DiffEqFlux.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Forward mode (ForwardDiff.jl) and source-to-source (Zygote.jl)  automatic differentiation  is not fully-supported yet. For more detailed discussion see this issue.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Further resources:","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"DiffEqSensitivity algorithms","category":"page"},{"location":"Library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"Library/#Public-Interface-1","page":"Library","title":"Public Interface","text":"","category":"section"},{"location":"Library/#","page":"Library","title":"Library","text":"The following functions are designed for public use","category":"page"},{"location":"Library/#","page":"Library","title":"Library","text":"","category":"page"},{"location":"Library/#","page":"Library","title":"Library","text":"network_dynamics\nStaticVertex\nODEVertex\nStaticEdge\nODEEdge","category":"page"},{"location":"Library/#NetworkDynamics.network_dynamics","page":"Library","title":"NetworkDynamics.network_dynamics","text":"network_dynamics(vertices!, edges!, g; parallel = false)\n\nAssembles the the dynamical equations of the network problem into an ODEFunction compatible with the DifferentialEquations.jl solvers. Takes as arguments an array of VertexFunctions vertices!, an array of EdgeFunctions edges! and a LightGraph.jl object g. The optional argument parallel is a boolean value that denotes if the central loop should be executed in parallel with the number of threads set by the environment variable JULIANUMTHREADS.\n\n\n\n\n\nPromotes StaticEdge to StaticDelayEdge if there is a DDEVertex\n\n\n\n\n\nPromotes ODEVertex to DDEVertex if there is a StaticDelayEdge\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.NDFunctions.StaticVertex","page":"Library","title":"NetworkDynamics.NDFunctions.StaticVertex","text":"StaticVertex(f!, dim, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a static node and has to respect the following calling syntax\n\nf!(v, e_s, e_t, p, t) -> nothing\n\nHere  v, p and t are the usual arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively.\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.NDFunctions.ODEVertex","page":"Library","title":"NetworkDynamics.NDFunctions.ODEVertex","text":"ODEVertex(f!, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a dynamic node and has to respect the following calling syntax\n\nf!(dv, v, e_s, e_t, p, t) -> nothing\n\nHere dv, v, p and t are the usual ODE arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively.\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * dv = f! will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.NDFunctions.StaticEdge","page":"Library","title":"NetworkDynamics.NDFunctions.StaticEdge","text":"StaticEdge(f!, dim, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a static edge and has to respect the following calling syntax\n\nf!(e, v_s, v_t, p, t) -> nothing\n\nHere  e, p and t are the usual arguments, while v_s and v_d are arrays containing the vertices which are the source and destination of the described edge.\n\ndim is the number of independent variables in the edge equations and sym is an array of symbols for these variables.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.NDFunctions.ODEEdge","page":"Library","title":"NetworkDynamics.NDFunctions.ODEEdge","text":"ODEEdge(f!, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a dynamic edge and has to respect the following calling syntax\n\nf!(de, e, v_s, v_t, p, t) -> nothing\n\nHere  de, e, p and t are the usual arguments, while v_s and v_d are arrays containing the vertices which are the source and destination of the described edge.\n\ndim is the number of independent variables in the edge equations and sym is an array of symbols for these variables. For more details see the documentation. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * de = f! will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"directed_and_weighted_graphs/#Neurodynamic-model-of-synchronization-in-the-human-brain-1","page":"Directed and weighted graphs","title":"Neurodynamic model of synchronization in the human brain","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"An IJulia notebook corresponding to this tutorial is available on GitHub.","category":"page"},{"location":"directed_and_weighted_graphs/#Topics-covered-in-this-tutorial-include:-1","page":"Directed and weighted graphs","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"constructing a directed, weighted graph from data\nsome useful macros\nparameter handling\nstiff equations","category":"page"},{"location":"directed_and_weighted_graphs/#The-FitzHugh-Nagumo-model-1","page":"Directed and weighted graphs","title":"The FitzHugh-Nagumo model","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Dynamics of spiking neurons have been described in a simplified manner by the FitzHugh-Nagumo model.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"beginaligned\nvarepsilon dot u   =  u - fracu^33 - v \ndot v  =  u + a\nendaligned","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Here u is a fast, excitatory variable corresponding to the membrane potential and v is a slower, inhibitory varibale. varepsilon is a parameter separating these time-scales, and a is a control parameter.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"In simplified models of the brain, such relaxation oscillators may be used to model individual neurons, clusters of neurons or even larger areas in the brain. The FitzHugh-Nagumo model has been widely used for studying synchronization in neuronal activity, which in turn has been connected to physiological phenomena such as epileptic seizures.","category":"page"},{"location":"directed_and_weighted_graphs/#Coupling-relaxation-oscillators-1","page":"Directed and weighted graphs","title":"Coupling relaxation oscillators","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"While different coupling schemes for FitzHugh-Nagumo oscillators have been proposed, in this tutorial we focus on coupling of the excitatory variables via electrical gap junctions, as described by the following system of equations.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"beginaligned\nvarepsilon dot u_i  =  u_i - fracu_i^33 - v_i - sigma sum_j=1^N G_ij(u_i - u_j) \ndot v_i  =   u_i + a\nendaligned","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"This is a simple diffusive coupling mediated by the difference between activation potentials in pairs of neurons. A similar coupling term was introduced in the \"getting started\" tutorial.","category":"page"},{"location":"directed_and_weighted_graphs/#The-network-topology-a-brain-atlas-1","page":"Directed and weighted graphs","title":"The network topology - a brain atlas","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"In the following we will use a directed and weigthed network encoding the strength and directionality of coupling between 90 different areas of the brain [N. Tzourio-Mazoyer, 2002].","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The network weight matrix is given as a text file containing 90 lines with 90 numbers representing the coupling strength and separated by commas ,. The data can be conveniently read into a matrix with the DelimitedFiles module.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using DelimitedFiles\n# adjust the load path for your filesystem!\nG = readdlm(joinpath(@__DIR__, \"../../examples/Norm_G_DTI.txt\"), ',', Float64, '\\n')\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The data structure for directed, weighted graphs is provided by the package SimpleWeightedGraphs.jl which is based on LightGraphs.jl.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using SimpleWeightedGraphs, LightGraphs\n\n# First we construct a weighted, directed graph\ng_weighted = SimpleWeightedDiGraph(G)\n\n# For later use we extract the edge.weight attributes\n# . is the broadcasting operator and gets the attribute :weight for every edge\nedge_weights = getfield.(collect(edges(g_weighted)), :weight)\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#Setting-up-the-ODEProblem-1","page":"Directed and weighted graphs","title":"Setting up the ODEProblem","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Defining VertexFunction and EdgeFunction is similar to the example before. The macros @inline and Base.@propagate_inbounds give the compiler more freedom to compile efficient code. For more details see the julia documentation.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using NetworkDynamics\n\n@inline Base.@propagate_inbounds function fhn_electrical_vertex!(dv, v, e_s, e_d, p, t)\n    dv[1] = v[1] - v[1]^3 / 3 - v[2]\n    dv[2] = (v[1] - a) * Ïµ\n    for e in e_s\n        dv[1] -= e[1]\n    end\n    for e in e_d\n        dv[1] += e[1]\n    end\n    nothing\nend\n\n@inline Base.@propagate_inbounds function electrical_edge!(e, v_s, v_d, p, t)\n    e[1] =  p * (v_s[1] - v_d[1]) # * Ï\n    nothing\nend\n\nodeelevertex = ODEVertex(f! = fhn_electrical_vertex!, dim = 2, sym=[:u, :v]);\nelectricaledge = StaticEdge(f! = electrical_edge!, dim = 1)\n\nfhn_network! = network_dynamics(odeelevertex, electricaledge, g_weighted)\n\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Note that the multiplication with the coupling strength sigma has been commented out. Since sigma is the same for every edge we can absorb this multiplication into the edge weight parameter p. Since our network has almost 8000 edges, this saves 8000 multiplications at every function call and leads to an 8-fold increase in performance.","category":"page"},{"location":"directed_and_weighted_graphs/#Parameter-handling-1","page":"Directed and weighted graphs","title":"Parameter handling","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"# Defining global parameters\n\nN = 90         # number of nodes\nconst Ïµ = 0.05 # global variables that are accessed several times should be declared `const`\nconst a = .5\nconst Ï = .5\n\n# Tuple of parameters for nodes and edges\n\np = (nothing, Ï * edge_weights)\n\n# Initial conditions\n\nx0 = randn(2N) * 5\n\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The behaviour of network_dynamics changes with the type of parameters p being passed. When p is an Array, the entire Array will be passed to each VertexFunction and EdgeFunction. When p is a tuple of two Arrays with lengths corresponding to the number of nodes and number of edges respectively, then network_dynamics passes only the edge or node parameters with the index of the edge or node. When there are no parameters for either edges or nodes the value nothing may be used.","category":"page"},{"location":"directed_and_weighted_graphs/#Solving-the-system-1","page":"Directed and weighted graphs","title":"Solving the system","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Now we are ready to create an ODEProblem. Since for some choices of parameters the FitzHugh-Nagumo model is stiff (i.e. numerically unstable), we use a solver with automated stiffness detection. Such a solver switches to a more stable solver only when the solution enters a region of phase space where the problem is numerically unstable. In this case we use Tsit5 and switch to TRBDF2 when necessary. AutoTsit5 is the switching version of the Tsit5 algorithm.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using OrdinaryDiffEq\n\ntspan = (0., 200.)\nprob  = ODEProblem(fhn_network!, x0, tspan, p)\nsol   = solve(prob, AutoTsit5(TRBDF2()));\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#Plotting-1","page":"Directed and weighted graphs","title":"Plotting","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The plot of the excitatory variables shows that they synchronize for this choice of parameters.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using Plots\n\nplot(sol, vars = idx_containing(fhn_network!, :u), legend = false, ylim=(-5, 5));\nsavefig(\"fhnsync.svg\") # hide","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"(Image: )","category":"page"},{"location":"getting_started_with_network_dynamics/#getting_started-1","page":"Getting started","title":"Network diffusion","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"This introductory example explains the use of the basic types and constructors in NetworkDynamics.jl by modeling a simple diffusion on an undirected network. A corresponding IJulia notebook is available on GitHub.","category":"page"},{"location":"getting_started_with_network_dynamics/#Theoretical-background-1","page":"Getting started","title":"Theoretical background","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Diffusion processes are relevant for phenomena as diverse as heat conduction, electrical currents, and random walks. Generally speaking they describe the tendency of systems to evolve towards a state of equally distributed heat, charge or concentration. In such system the local temperature (or concentration) changes according to its difference with its neighborhood, i.e. the temperature gradient.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Let g be a graph with N nodes and adjacency matrix A. Let v = (v_1 dots v_n) be a vector of (abstract) temperatures or concentrations at each node i = 1 dots N. Then the rate of change of state v_i is described by its difference with its neighbors and we obtain the following ordinary differential equation","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"dot v_i = - sum_i=1^N A_ij (v_i - v_j)","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j it will decrease along that edge.","category":"page"},{"location":"getting_started_with_network_dynamics/#Modeling-diffusion-in-NetworkDynamics.jl-1","page":"Getting started","title":"Modeling diffusion in NetworkDynamics.jl","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"From the above considerations we see that in this model the nodes do not have any internal dynamics - if a node was disconnected from the rest of the network its state would never change, since then A_ij = 0  forall j and hence dot v_i = 0. This means that the evolution of a node depends only on the interaction with its neighbors. In NetworkDynamics.jl interactions with neighbors are described by equations for the edges.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"function diffusionedge!(e, v_s, v_d, p, t)\n    # usually e, v_s, v_d are arrays, hence we use the broadcasting operator .\n    e .= v_s - v_d\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The function diffusionedge! takes as inputs the current state of the edge e, its source vertex v_s, its destination vertex v_d, a vector of parameters p and the time t. In order to comply with the syntax of NetworkDynamics.jl we always have to define functions for static edges with exactly these arguments, eventhough we do not need p and t for the diffusion example.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"diffusionedge! is called a mutating function, since it modifies (or mutates) one of its inputs, namely the edge state e. As a convention in julia names of mutating functions end with an !. The use of mutating functions reduces allocations and thereby speeds up computations. After the function call the edge's value e equals the difference between its source and its destination vertex (i.e. the discrete gradient along that edge).","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The contributions of the different edges are then summed up in each vertex.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"function diffusionvertex!(dv, v, e_s, e_d, p, t)\n    # usually v, e_s, e_d are arrays, hence we use the broadcasting operator .\n    dv .= 0.\n    # edges for which v is the source\n    for e in e_s\n        dv .-= e\n    end\n    # edges for which v is the destination\n    for e in e_d\n        dv .+= e\n    end\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Just like above the input arguments v, e_s, e_d, p, t are mandatory for the syntax of vertex functions. The additional input dv corresponding to the derivative of the vertex' state is mandatory for vertices described by ordinary differential equations.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Something unexpected happens in the for-loops: The contributions of the connecting edges are subtracted or added depending on v being the source or the destination of an edge. However we are modeling diffusion on an undirected network, hence the concepts of source and destination are not defined!","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The reason for this syntax is found in the LightGraphs.jl package on which NetworkDynamics.jl is based.","category":"page"},{"location":"getting_started_with_network_dynamics/#How-to-deal-with-abstract-edge-directions-in-undirected-graphs-1","page":"Getting started","title":"How to deal with abstract edge directions in undirected graphs","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"LightGraphs.jl implements edges as pairs of node indices i and j. Pairs are basic julia data types consisting of two fixed elements, definded by writing i => j. In directed graphs these pairs additionally represent the direction in which the edge is pointing (from the first two the second element). In undirected graphs every edge is represent by only a single pair i => j if index i is smaller than index j and j => i otherwise. Hence, even for undirected graphs every edge has an abstract direction, specified by the pair of indices of the attached nodes.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"A LightGraphs.jl user, who is only interested in undirected graphs, usually does not have to deal with this abstract directionality. However since NetworkDynamics.jl is interfacing directly to the underlying graph objects, we have to keep in mind that every edge has an abstract direction and thus a source and a destination.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"In the diffusion example the coupling terms have to be modified accordingly. Assume node i is connected to node j by an undirected edge.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Case: i => j","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"If the abstract edge direction points from i to j then the edge value will be v_i - v_j. Hence we have to subtract this term from dv.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Case: j => i","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"In this case the edge value is v_j - v_i. Of course that's just -(v_i - v_j) and can be directly added to dv.","category":"page"},{"location":"getting_started_with_network_dynamics/#Caveat:-Symmetric-and-asymmetric-coupling-terms-1","page":"Getting started","title":"Caveat: Symmetric and asymmetric coupling terms","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The coupling term g(i j) = v_i - v_j is anti-symmetric, that is g(ij) = - g(ji) and hence multiplying some edge values with -1 restores the behaviour of undirected edges. The same property holds for other important coupling terms like g(ij) = sin(v_i - v_j). On the other hand, if the coupling term happens to be symmetric, i.e. g(ij) = g(ji) we don't have to worry about the abstract direction at all.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"However, some coupling terms are neither symmetric nor anti-symmetric like the chemical coupling between neurons. In this case it is a viable strategy to double the number of edge variables, compute both outcomes and use only one depending on the abstract direction of the edge. For more details have a look at the example on chemical coupling.","category":"page"},{"location":"getting_started_with_network_dynamics/#Constructing-the-network-1","page":"Getting started","title":"Constructing the network","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"With the preliminaries out of the way, it only takes a few steps to assemble the network dynamics.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"using LightGraphs\n\nN = 20 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The BarabÃ¡siâAlbert model generates a scale-free random graph.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"using NetworkDynamics\n\nnd_diffusion_vertex = ODEVertex(f! = diffusionvertex!, dim = 1)\nnd_diffusion_edge = StaticEdge(f! = diffusionedge!, dim = 1)\n\nnd = network_dynamics(nd_diffusion_vertex, nd_diffusion_edge, g)\n\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"ODEVertexband StaticEdge are functions wrappers that equip the functions we defined above with additional information like dim and return objects of type VertexFunction and EdgeFunction. Then the key constructor network_dynamics combines them with the topological information contained in the graph g and returns an ODEFunction compatible with the solvers of DifferentialEquations.jl. The keyword dim specifies the number of variables at each edge or node.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"using OrdinaryDiffEq\n\nx0 = randn(N) # random initial conditions\node_prob = ODEProblem(nd, x0, (0., 4.))\nsol = solve(ode_prob, Tsit5());\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"We are solving the diffusion problem on the time interval 0 4 with the Tsit5() algorithm, which is recommended  by the authors of DifferentialEquations.jl for most non-stiff problems.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"using Plots\nplot(sol, vars = syms_containing(nd, \"v\"));\nsavefig(\"diff1.svg\"); nothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The plotting is straightforward. The vars keyword allows us to pass a list of indices or symbols specifiying the variables we want to plot. Symbols can be thought of as names given to the interal variables of an ODEFunction, much like the variables x or phi in mathematical notation. The default symbol for vertex variables is v, however we are free to specify other symbols by passing them to the ODEVertex constructor.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"syms_containing is a helper function that returns all symbols of an ODEProblem containg a specific string (or symbol).","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"To illustrate a very simple multi-dimensional case, in the following we simulate two independent diffusions on an identical network. The first uses the symbol x and is started with initial conditions drawn from the standard normal distribution N(01), the second uses the symbol Ï with squared standard normal inital conditions.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The symbols have to be passed with the keyword sym to ODEVertex.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"N = 10 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\n# We will have two independent diffusions on the network, hence dim = 2\nnd_diffusion_vertex_2 = ODEVertex(f! = diffusionvertex!, dim = 2, sym = [:x, :Ï])\nnd_diffusion_edge_2 = StaticEdge(f! = diffusionedge!, dim = 2)\nnd_2 = network_dynamics(nd_diffusion_vertex_2, nd_diffusion_edge_2, g)\n\nx0_2 = vec(transpose([randn(N).^2 randn(N)])) # x ~ N(0,1)^2; Ï ~ N(0,1)\node_prob_2 = ODEProblem(nd_2, x0_2, (0., 3.))\nsol_2 = solve(ode_prob_2, Tsit5());\n\n\n# Try plotting the variables Ï_i yourself. [To write Ï type \\phi and press TAB]\nplot(sol_2, vars = syms_containing(nd_2, \"x\"));\nsavefig(\"diff2.svg\"); nothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting_started_with_network_dynamics/#Appendix:-The-network-Laplacian-L-1","page":"Getting started","title":"Appendix: The network Laplacian L","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The diffusion equation on a network can be rewritten as","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"dot v_i  = d_i v_i - sum_i=1^N A_ij v_j = d_i v_i - e_i^T A v          ","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"where d_i is the degree of node i and e_i^T is the i-th standard basis vector. Introducing the diagonal matrix D that has the degree of node i in its i-th row and the Laplacian matrix L = D - A we arrive at","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"dot v = e_i^T(D - A) v","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"and finally","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"dot v = L v","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"This is a linear system of ODEs and its solution is a matrix exponential. To study the asymptotic behaviour of the system it suffices to analyze the eigenspectrum of L. For this reason L is an important construction in network science.","category":"page"},{"location":"#NetworkDynamics-1","page":"General","title":"NetworkDynamics","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"A package for working with dynamical systems on complex networks. NetworkDynamics.jl provides an interface between LightGraphs.jl and DifferentialEquations.jl. It allows to define several types of dynamic and static nodes and edges and to link them up in order to create complex network dynamics.","category":"page"},{"location":"#","page":"General","title":"General","text":"At the moment the behaviour of a node or an edge can be described by algebraic equations or by ordinary differential equations (ODE). Support for stochastic differential equations (SDE) and delay differential equations (DDE) will be added in future releases.","category":"page"},{"location":"#Installation-1","page":"General","title":"Installation","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Installation is straightforward with Julia's package manager.","category":"page"},{"location":"#","page":"General","title":"General","text":"(v1.3) pkg> add NetworkDynamics","category":"page"},{"location":"#PowerDynamics-1","page":"General","title":"PowerDynamics","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"PowerDynamics.jl is an open-source framework for dynamic power grid modeling and analysis build on top of NetworkDynamics.jl.","category":"page"},{"location":"#Overview-1","page":"General","title":"Overview","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"The key construction is the function network_dynamics that takes in two arrays of functions describing the local dynamics on the edges and nodes of a graph g, and returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"#","page":"General","title":"General","text":"nd = network_dynamics(vertices!::Array{VertexFunction},  edges!::Array{EdgeFunction}, g)\nnd(dx, x, p, t)","category":"page"},{"location":"BasicConstructors/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The key constructor network_dynamics assembles the dynamics of the whole network from functions for the single vertices and edges of the graph g. Since the equations describing the local dynamics may differ strongly from each other, the types VertexFunction and EdgeFunction are introduced. They provide a unifying interface between different classes of nodes and edges. Both have several subtypes that account for the different classes of equations that may represent the local dynamics. At the moment algebraic (static) equations and ordinary differential equations (ODEs) are supported:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# VertexFunctions\nStaticVertex(vertexfunction!, dimension, symbol)\nODEVertex(vertexfunction!, dimension, mass_matrix, symbol)\n\n# EdgeFunctions\nStaticEdge(edgefunction!, dimension, symbol)\nODEEdge(edgefunction!, dimension, mass_matrix, symbol)","category":"page"},{"location":"BasicConstructors/#VertexFunctions-1","page":"Functions","title":"VertexFunctions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Given a set of (algebraic or differential) equations describing a node or an edge the first step is to turn them into a mutating function vertexfunction!. Depending on the class of the function vertexfunction!, the constructors StaticVertex or ODEVertex are called in order to turn vertexfunction! into a VertexFunction object compatible with network_dynamics.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Since in general the state of a vertex depends on the vertex value itself as well as on the in- and outgoing edges, the function vertexfunction! has to respect one of the following calling syntaxes.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# For static nodes\nfunction vertexfunction!(v, e_s, e_d, p, t) end\n# For dynamic nodes\nfunction vertexfunction!(dv, v, e_s, e_d, p, t) end","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Here dv, v, p and t are the usual ODE arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively. The typical case of diffusive coupling on a directed graph could be described as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"function vertex!(dv, v, e_s, e_d, p, t)\n    dv .= 0.\n    for e in e_s\n        dv .-= e\n    end\n    for e in e_d\n        dv .+= e\n    end\n    nothing\nend","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"warning: Warning\nThe arguments e_s and e_d are obligatory even if the graph is undirected and no distinction between source and destination can be made. This is necessary since LightGraphs.jl implements an undirected graph in the same way as a directed graphs, but ignores the directionality information. Therefore some care has to be taken when dealing with assymetric coupling terms. A detailed example can be found  in the Getting started tutorial.","category":"page"},{"location":"BasicConstructors/#[StaticVertex](@ref)-1","page":"Functions","title":"StaticVertex","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"If a vertex is described by an algebraic equation  vertexfunction!(v, e_s, e_d, p, t), i.e. dv = 0 the VertexFunction is constructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"StaticVertex(vertexfunction!, dim, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Here, dim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. For example, if a node models a constant input I = p, then dim = 1 and sym = [:I]. For more details on the use of symbols, check out the Getting started tutorial and the Julia documentation. The use of symbols makes it easier to later fish out the interesting variables one wants to look at.","category":"page"},{"location":"BasicConstructors/#[ODEVertex](@ref)-1","page":"Functions","title":"ODEVertex","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"If a vertex has local dynamics vertexfunction!(dv, v, e_s, e_d, p, t) described by an ODE the VertexFunction is contructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEVertex(vertexfunction!, dim, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"As above, dim is the number of independent variables in the vertex equations and sym corresponds to the symbols of these variables.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the local system M * dv = vertexfunction! will be solved. network_dynamics assembles all local mass matrices into one global mass matrix that can be passed to a differential equation solver like Rodas4.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"One may also call ODEVertex with keyword arguments, omitting optional arguments:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEVertex(f! = vertexfunction!, dim = dim)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The function then defaults to using the identity as mass matrix and [:v for i in 1:dimension] as symbols.","category":"page"},{"location":"BasicConstructors/#EdgeFunctions-1","page":"Functions","title":"EdgeFunctions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Similar to the case of vertices, an edge is described by mutating function edgefunction!. At the moment the constructors StaticEdge and ODEEdge are available. edgefunction! has to respect one of the following syntaxes:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# For static edges\nfunction edgefunction!(e, v_s, v_d, p, t) end\n# For dynamics edges\nfunction edgefunction!(de, e, v_s, v_d, p, t) end","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Just like above, de, e, p and t are the usual ODE arguments, while v_s and v_d are the source and destination vertices respectively.","category":"page"},{"location":"BasicConstructors/#[StaticEdge](@ref)-1","page":"Functions","title":"StaticEdge","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Static here means, that the edge value described by edgefunction! only depends on the values of the vertices the edge connects to and that no derivative of the edge's internal state is involved. One very simple and natural example is a diffusive edge:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"edgefunction! = (e, v_s, v_d, p, t) -> e .= v_s .- v_d","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"In this case the EdgeFunction is constructed by","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"StaticEdge(edgefunction!, dim, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The keywords are the same as for the vertices.","category":"page"},{"location":"BasicConstructors/#[ODEEdge](@ref)-1","page":"Functions","title":"ODEEdge","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"For problems where edgefunction! describes the differential of an edge value, we use the ODEEdge function. An example for such a system is given by:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"edgefunction! = (de, e, v_s, v_d, p, t) -> de .= 1000 * (v_s .- v_d .- e)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The EdgeFunction object is constructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEEdge(edgefunction!, dim, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The keywords are the same as for the vertices. For ODEEdge the same simplified construction rules apply when keyword arguments are used.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEEdge(f! = edgefunction!, dim = n)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"In this case the function defaults to using the identity as mass matrix and [:e for in 1:dimension] as symbols.","category":"page"},{"location":"BasicConstructors/#Constructor-1","page":"Functions","title":"Constructor","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The key constructor is the function network_dynamics that takes in two arrays of EdgeFunctions and VertexFunctions describing the local dynamics on the edges and nodes of a graph g, given as a LightGraphs.jl object. It returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertices!::Array{VertexFunction},\n                      edges!::Array{EdgeFunction}, g)\nnd(dx, x, p, t)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"If all vertices, respectively edges share the same VertexFunction or EdgeFunction, than network_dynamics can be conveniently called with these functions as arguments.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertexfunction!::VertexFunction,\n                      edgefunction!::EdgeFunction, g)\n","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The optional keyword argument parallel is false by default and can be set to true if a multi-threaded ODEFunction should be used. This may significantly improve performance on multi-core machines, for more details see section Multi-Threading.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertexfunction!::VertexFunction,\n                      edgefunction!::EdgeFunction, g, parallel=true)\n","category":"page"},{"location":"BasicConstructors/#Example-1","page":"Functions","title":"Example","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Let's look at an example. First we define our graph as well as the differential systems connected to its vertices and edges:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"using NetworkDynamics, LightGraphs\n\ng = erdos_renyi(10, 25) # random graph with 10 vertices and 25 edges\n\nfunction vertexfunction!(dv, v, e_s, e_d, p, t)\n  dv .= 0\n  for e in e_s\n    dv .-= e\n  end\n  for e in e_d\n    dv .+= e\n  end\nend\n\nfunction edgefunction!(de, e, v_s, v_d, p, t)\n     de .= 1000 .*(v_s .- v_d .- e)\n     nothing\nend\n\nvertex = ODEVertex(f! = vertexfunction!, dim = 1)\nvertexarr = [vertex for v in vertices(g)]\n\nedge = ODEEdge(f! = edgefunction!, dim = 1)\nedgearr = [edge for e in edges(g)]\n\nnd = network_dynamics(vertexarr, edgearr, g)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Now we have an ODEFunction nd that can be solved with the tools provided by DifferentialEquations.jl.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"For more details check out the Tutorials section.","category":"page"}]
}
