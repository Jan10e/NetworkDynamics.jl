<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Experimental DDE Tutorial · NetworkDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NetworkDynamics</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li><a class="tocitem" href="../BasicConstructors/">Functions</a></li><li><a class="tocitem" href="../parameters/">Parameter handling</a></li><li><a class="tocitem" href="../Multithreading/">Multi-Threading</a></li><li><a class="tocitem" href="../Library/">Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_network_dynamics/">Getting started</a></li><li><a class="tocitem" href="../directed_and_weighted_graphs/">Directed and weighted graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Experimental DDE Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Experimental DDE Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FHell/NetworkDynamics.jl/blob/master/docs/src/DDEVertex.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Experimental-DDE-Tutorial-1"><a class="docs-heading-anchor" href="#Experimental-DDE-Tutorial-1">Experimental DDE Tutorial</a><a class="docs-heading-anchor-permalink" href="#Experimental-DDE-Tutorial-1" title="Permalink"></a></h1><p>An <code>IJulia</code> <a href="https://github.com/FHell/NetworkDynamics.jl/tree/master/examples">notebook</a> corresponding to this tutorial will be available on GitHub soon.</p><h4 id="Topics-covered-in-this-tutorial-include:-1"><a class="docs-heading-anchor" href="#Topics-covered-in-this-tutorial-include:-1">Topics covered in this tutorial include:</a><a class="docs-heading-anchor-permalink" href="#Topics-covered-in-this-tutorial-include:-1" title="Permalink"></a></h4><ul><li>constructing a watts_strogatz graph</li><li>diffusion delay differential equation (DDE)</li><li>parameter handling with DDE&#39;s</li><li>stiff equations</li><li>Kuramoto Delay Model</li></ul><h2 id="Network-Diffusion-1"><a class="docs-heading-anchor" href="#Network-Diffusion-1">Network Diffusion</a><a class="docs-heading-anchor-permalink" href="#Network-Diffusion-1" title="Permalink"></a></h2><p>This example explains the use of delay differential equations (DDE&#39;s) in NetworkDynamics.jl by modeling a simple diffusion on an undirected ring network with delay.</p><p>Let <span>$g$</span> be a graph with <span>$N$</span> nodes and adjacency matrix <span>$A$</span>. Let <span>$v = (v_1, \dots, v_n)$</span> be a vector of (abstract) temperatures or concentrations at each node <span>$i = 1, \dots, N$</span>. The rate of change of state <span>$v_i$</span> in this artificial example is described by the delay value of <span>$v_i$</span> with delay <span>$\Tau$</span> and its difference with its neighbors with coupling strength <span>$\sigma$</span>. We obtain the following ordinary differential equation</p><div>\[\begin{aligned}
\dot v_i = - v_i(\Tau) - \sigma * \sum_{i=1}^N A_{ij} (v_i - v_j)
\end{aligned}\]</div><p>The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node <span>$i$</span> is higher than at its neighboring node <span>$j$</span> it will decrease along that edge.</p><h2 id="Modeling-diffusion-with-delay-in-NetworkDynamics.jl-1"><a class="docs-heading-anchor" href="#Modeling-diffusion-with-delay-in-NetworkDynamics.jl-1">Modeling diffusion with delay in NetworkDynamics.jl</a><a class="docs-heading-anchor-permalink" href="#Modeling-diffusion-with-delay-in-NetworkDynamics.jl-1" title="Permalink"></a></h2><p>From the equation above we see that in this model the dynamics of the nodes consist of internal dynamics as well as a coupling term with the neighboring nodes. In NetworkDynamics.jl the interactions with the neighbors are described by equations for the edges.</p><pre><code class="language-julia">function diffusionedge!(e, v_s, v_d, p, t)
   # usually e, v_s, v_d are arrays, hence we use the broadcasting operator .
   e .= .1 * (v_s .- v_d)
   nothing
end</code></pre><p>The internal dynamics are determined by the delay value <span>$\dot v_i = v_i(\Tau)$</span> and are described in the vertex function with help of the history array <span>$h_v$</span> containing the delay values of the vertex.</p><pre><code class="language-julia">function diffusionvertex!(dv, v, e_s, e_d, h_v, p, t)
   # usually dv, v, e_s, e_d, h_v are arrays, hence we use the broadcasting operator .
   # h_v is the history array of the vertices
   dv .= -h_v
   # edges for which v is the source
   for e in e_s
       dv .-= e
   end
   # edges for which v is the destination
   for e in e_d
       dv .+= e
   end
   nothing
end</code></pre><h1 id="Constructing-the-Network-Dynamics-1"><a class="docs-heading-anchor" href="#Constructing-the-Network-Dynamics-1">Constructing the Network Dynamics</a><a class="docs-heading-anchor-permalink" href="#Constructing-the-Network-Dynamics-1" title="Permalink"></a></h1><p>Constructing the network dynamics is straightforward</p><pre><code class="language-julia">using LightGraphs

### Defining a graph

N = 20 # number of nodes
k = 8  # average degree
g = watts_strogatz(N, k, 0.) # ring-network</code></pre><pre><code class="language-none">{20, 80} undirected simple Int64 graph</code></pre><p>The Watts-Strogatz algorithm constructs a regular-ring network with <span>$N$</span> nodes, <span>$k$</span> neighbors and a probability <span>$p$</span> of rewiring links, which is chosen as <span>$p=0$</span> here.</p><pre><code class="language-julia">using NetworkDynamics

nd_diffusion_vertex = DDEVertex(f! = diffusionvertex!, dim = 1)
nd_diffusion_edge = StaticEdge(f! = diffusionedge!, dim = 1)

nd = network_dynamics(nd_diffusion_vertex, nd_diffusion_edge, g)</code></pre><pre><code class="language-none">(::DiffEqBase.DDEFunction{true,nd_DDE_Static{LightGraphs.SimpleGraphs.SimpleGraph{Int64},Array{Float64,1},Array{Float64,1},DDEVertex{typeof(Main.ex-DDEVertex.diffusionvertex!)},StaticDelayEdge{NetworkDynamics.NDFunctions.var&quot;#65#66&quot;{StaticEdge{typeof(Main.ex-DDEVertex.diffusionedge!)}}}},LinearAlgebra.UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Array{Symbol,1},Nothing}) (generic function with 2 methods)</code></pre><p>Now we hand over the functions we have defined above to the constructors <code>DDEVertex</code> and <code>StaticEdge</code>, adding information on the dimension of variables at each edge or node with keyword <strong><code>dim</code></strong>. The wrapper function <code>DDEVertex</code> is a new feature describing internal delay dynamics of nodes. The resulting objects can then be delivered to the key constructor <code>network_dynamics</code>, which adds topological information of graph <strong><code>g</code></strong> and returns an <code>DDEFunction</code>, which is compatible with the solvers of <code>DifferentialEquations.jl</code>.</p><h1 id="Simulation-1"><a class="docs-heading-anchor" href="#Simulation-1">Simulation</a><a class="docs-heading-anchor-permalink" href="#Simulation-1" title="Permalink"></a></h1><p>First we set the initial conditions, the time-interval <code>tspan</code>, construct the history function <code>h(x,p,t)</code> and set the parameters <code>p</code>, which are now extended to take parameters for the delay-time too.</p><pre><code class="language-julia">x0 = randn(N) # random initial conditions
tspan = (0., 10.) #time interval

# history function defaults to all 1. and is in-place to save allocations
h(out, p, t) = (out .= 1.)

#parameters p = (vertex parameters, edge parameters, delay time)
p = (nothing, nothing, 1.)</code></pre><pre><code class="language-none">(nothing, nothing, 1.0)</code></pre><p>Then we solve the diffusion problem. The constructor <code>DDEProblem</code> is from the package <code>DealyDiffEq.jl</code> and wraps up the <code>DDEFunction</code> with the initial conditions <code>x0</code> , the history function <code>h</code> , time-interval <code>tspan</code> and parameters <code>p</code>, which can than be handed over to the <code>solve</code> method.</p><pre><code class="language-">using OrdinaryDiffEq
using DelayDiffEq

dde_prob = DDEProblem(nd, x0, h, tspan, p)
sol = solve(dde_prob, MethodOfSteps(Tsit5()))</code></pre><p>We solve the problem with delay on the time interval <span>$[0, 10]$</span> with the <code>Tsit5()</code> algorithm, which is the Tsitouras 5/4 Runge-Kutta method (a free 4th order interpolant), recommended for solving non-stiff problems. The additional algorithm <code>MethodOfSteps</code> translates an <code>OrdinaryDiffEq.jl</code> ODE solver method into a method for delay differential equations which is highly efficient.</p><h2 id="Bonus:-Two-independet-diffusions-1"><a class="docs-heading-anchor" href="#Bonus:-Two-independet-diffusions-1">Bonus: Two independet diffusions</a><a class="docs-heading-anchor-permalink" href="#Bonus:-Two-independet-diffusions-1" title="Permalink"></a></h2><p>In this extension of the first example, we will have two independent diffusions on the same network with variables <span>$x$</span> and <span>$\phi$</span>, such that the <strong><code>dim</code></strong>=2. First we construct the <code>network_dynamics</code>-objects.</p><pre><code class="language-julia">nd_diffusion_vertex_2 = DDEVertex(f! = diffusionvertex!, dim = 2, sym = [:x, :ϕ])
nd_diffusion_edge_2 = StaticDelayEdge(f! = diffusionedge!, dim = 2)
nd_2 = network_dynamics(nd_diffusion_vertex_2, nd_diffusion_edge_2, g)</code></pre><pre><code class="language-none">(::DiffEqBase.DDEFunction{true,nd_DDE_Static{LightGraphs.SimpleGraphs.SimpleGraph{Int64},Array{Float64,1},Array{Float64,1},DDEVertex{typeof(Main.ex-DDEVertex.diffusionvertex!)},StaticDelayEdge{typeof(Main.ex-DDEVertex.diffusionedge!)}},LinearAlgebra.UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Array{Symbol,1},Nothing}) (generic function with 2 methods)</code></pre><p>Secondly, the initial conditions are generated, where the first N values correspond to variable <code>x</code> and the values with indices from N+1 to 2N to state-variable <code>ϕ</code>, where <span>$x \sim  N(0,1)$</span>; <span>$ϕ \sim N(0,1)^2$</span>. The parameter value for the delay <span>$\Tau$</span> is set to 1.0.</p><pre><code class="language-julia">x0_2 = Array{Float64,1}(vec([randn(N).-10 randn(N).^2]&#39;)) # x ~ \mathcal{N}(0,1); ϕ ~ \mathcal{N}(0,1)^2

p = (nothing, nothing, 1.) # p = (vertexparameters, edgeparameters, delaytime)</code></pre><pre><code class="language-none">(nothing, nothing, 1.0)</code></pre><p>Now we can define the <code>DDEProblem</code>and then solve it. The <code>DDEProblem</code> is a wrapper function, which delivers an <code>ODEFunction</code>, which is compatible with the solvers of <code>DelayDiffEq.jl</code>.</p><pre><code class="language-">dde_prob_2 = DDEProblem(nd_2, x0_2, h, tspan, p)
sol_2 = solve(dde_prob_2, MethodOfSteps(Tsit5()));
plot(sol_2, legend=false)</code></pre><p>As a solver we use again <code>Tsit5()</code> with the <code>MethodOfSteps</code>-algorithm.</p><h2 id="Kuramoto-model-with-delay-1"><a class="docs-heading-anchor" href="#Kuramoto-model-with-delay-1">Kuramoto model with delay</a><a class="docs-heading-anchor-permalink" href="#Kuramoto-model-with-delay-1" title="Permalink"></a></h2><p>An additional example which will be explained in the following is the Kuramoto model. Instead of modeling a simple diffusion on an undirected ring network, we will use the Kuramoto model for the vertices and the edges but keep delay and the Watts-Strogatz graph as in the examples above.</p><p>Again, the interactions with the neighbors are described through the edge function. Unlike the diffusion example, here the edges now have a delay. For this reason we introduce the history arrays for the destination vertices and source vertices.</p><pre><code class="language-julia">function kuramoto_delay_edge!(e, v_s, v_d, h_v_s, h_v_d, p, t)
    # The coupling is no longer symmetric, so we need to store BOTH values (see tutorials for details)
    e[1] = p * sin(v_s[1] - h_v_d[1])
    e[2] = p * sin(h_v_s[1] - v_d[1])
    nothing
end</code></pre><p>Now, the contributions of the edges are summed up in each vertex so that we can define the vertex function for the Kuramoto model.</p><pre><code class="language-julia">function kuramoto_vertex!(dv, v, e_s, e_d, p, t)
    dv[1] = p
    for e in e_s
        dv[1] -= e[1]
    end
    for e in e_d
        dv[1] -= e[2]
    end
    nothing
end</code></pre><pre><code class="language-none">kuramoto_vertex! (generic function with 1 method)</code></pre><p>As for the diffusion example, we now hand over the defined functions for the Kuramoto edges and vertices to the constructors <code>DDEVertex</code> and <code>StaticEdge</code> of NetworkDynamics.jl.</p><pre><code class="language-julia">kdedge! = StaticDelayEdge(f! = kuramoto_delay_edge!, dim=2)
kdvertex! = ODEVertex(f! = kuramoto_vertex!, dim = 1)</code></pre><pre><code class="language-none">ODEVertex{typeof(Main.ex-DDEVertex.kuramoto_vertex!)}(Main.ex-DDEVertex.kuramoto_vertex!, 1, LinearAlgebra.UniformScaling{Bool}(true), Symbol[:v])</code></pre><p>Note that the edges have the dimension two, since there is no more symmetric coupling for the Kuramoto case. Accordingly, we have to set the keywork argument <code>dim</code> of <code>StaticDelayEdge</code> to two. The returned objects (<code>nd_diffusion_vertex</code> and <code>nd_diffusion_edge</code>) are passed to the key construcor <code>network_dynamics</code> together with informations of the graph which are contained in <code>g</code>.</p><pre><code class="language-julia">nd! = network_dynamics(kdvertex!, kdedge!, g)</code></pre><pre><code class="language-none">(::DiffEqBase.DDEFunction{true,nd_DDE_Static{LightGraphs.SimpleGraphs.SimpleGraph{Int64},Array{Float64,1},Array{Float64,1},DDEVertex{NetworkDynamics.NDFunctions.var&quot;#51#52&quot;{ODEVertex{typeof(Main.ex-DDEVertex.kuramoto_vertex!)}}},StaticDelayEdge{typeof(Main.ex-DDEVertex.kuramoto_delay_edge!)}},LinearAlgebra.UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Array{Symbol,1},Nothing}) (generic function with 2 methods)</code></pre><p>The object <code>nd!</code> returned by <code>network_dynamics</code>, is compatible with the solvers of <code>DifferentialEquations</code>.</p><p>Afterwards, random initial conditions are set for all <span>$N$</span> nodes, as well as the simulation time <code>tspan</code>, the eigenfrequencies <code>ω</code> of the <span>$N$</span> vertices, and the parameters <code>p</code> for the edges, the vertices, and the delay. Since we are dealing with a system containg a time delay, we need to set the history function <code>h</code> as for the examples above. The history function sets all default entries to 1.0 and is in-place to save allocations.</p><pre><code class="language-julia">x0 = randn(N) # random initial conditions
# history function defaults to all 1. and is in-place to save allocations
h(out, p, t) = (out .= 1.)
# p = (vertexparameters, edgeparameters, delaytime)
ω = randn(N)
ω .-= sum(ω)/N
p = (ω, 2., 1.)
tspan = (0.,20.)</code></pre><pre><code class="language-none">(0.0, 20.0)</code></pre><p>As described for the diffusion exmaple above, the constructor <code>DDEProblem</code> is used to provide an object that can be solved using the <code>solve</code> method.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 20 July 2020 09:25">Monday 20 July 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
