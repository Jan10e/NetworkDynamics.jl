<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General · NetworkDynamics</title><link rel="canonical" href="https://juliaenergy.github.io/NetworkDynamics.jl/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NetworkDynamics</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>General</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#Static-lines-1">Static lines</a></li><li><a class="toctext" href="#Dynamic-lines-1">Dynamic lines</a></li></ul></li><li><a class="toctext" href="Functions_and_Constructors/">-</a></li><li><a class="toctext" href="StaticEdges/">-</a></li><li><a class="toctext" href="DynamicEdges/">-</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>General</a></li></ul><a class="edit-page" href="https://github.com/FHell/NetworkDynamics.jl/blob/master/docs_src/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>General</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NetworkDynamics.jl-1" href="#NetworkDynamics.jl-1">NetworkDynamics.jl</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>This package implements functions for defining and studying dynamics on networks. The key construction is a callable struct compatible with the DifferentialEquations.jl calling syntax.</p><pre><code class="language-julia">nd = network_dynamics(vertices!, edges!, g)
nd(dx, x, p, t)</code></pre><p>The first two parameters are the functions, or function arrays from which a network dynamics is built. The last parameter g is a graph encoding the network constructed with the LightGraphs.jl package. Note that the type network_dynamics is only a placeholder for the dynamics types we will now specify.</p><h2><a class="nav-anchor" id="Static-lines-1" href="#Static-lines-1">Static lines</a></h2><h4><a class="nav-anchor" id="Scalar-variables-1" href="#Scalar-variables-1">Scalar variables</a></h4><p>We will first look into the case where there is only a scalar variable on each vertex. A dynamical network with static lines (static meaning that the current on an edge depends solely on the values on the nodes it connects) is created via the scalar<em>static</em>lines function:</p><pre><code class="language-julia">ssl = scalar_static_lines(vertices!, edges!, g)</code></pre><p>The functions vertices! and edges! are of the form:</p><pre><code class="language-julia">vertices![n](dv[n],v[n],e_s[n],e_t[n],p,t)
edges![m](e[m],v_s,v_t,p,t)  </code></pre><p>Specifically, the given variables are:</p><pre><code class="language-julia">e_s[n] = [e[m] if s[m] == n for m in 1:length(lines!)]
e_t[n] = [e[m] if t[m] == n for m in 1:length(lines!)]
v_s= v[s[m]]
v_t= v[t[m]]</code></pre><p>The vectors s and t contain the information about the source and target of each edge, i.e. s[1] == 2 -&gt; The source of edge 1 is vertex 2. The function creates these vectors from the given graph, they can be accessed via the calling syntax ssl.s<em>e or ssl.t</em>e. The vectors e<em>s[n] and e</em>t[n] are containing the in- and outgoing edge values (or currents) of vertex n in the form of an array. Thus, one would classically sum over these in vertices!, but one is not restricted on doing this.</p><p>For example, a system of equations describing a simple diffusive network would be:</p><pre><code class="language-julia">using LightGraphs
g= barabasi_albert(10,5)
vertices! = [(dv,v,l_s,l_t,p,t) -&gt; dv .= sum(e_s) .- sum(e_t) for vertex in vertices(g)]
edges! = [(e,v_s,v_t,p,t) -&gt; e .= v_s .- v_t for edge in edges(g)]</code></pre><p>Here, the diffusiveness lies within the lines! function. It states that there is only a current between two nodes if these nodes have a non-equal value. This current then ultimatively leads to an equilibrium in which the value on any connected node is equal.</p><p>Note that one should (for performance reasons) and actually needs to put a dot before the mathematical operators. This is due to the use of views in the internals of the scalar<em>static</em>lines function.</p><p>We finally want to solve the defined diffusive system. This we do by using the well-known package DifferentialEquations.jl (see <a href="http://docs.juliadiffeq.org/latest/">here</a>). We also need to specify a set of initial values x0 as well as a time interval t for which we are solving the problem:</p><pre><code class="language-julia">using DifferentialEquations
using Plots
x0 = rand(10)
t = (0.,2.)
ssl = scalar_static_lines(vertices!,edges!,g)
ssl_prob = ODEProblem(ssl,x0,t)
sol = solve(ssl_prob)
plot(sol, legend = false)</code></pre><p><img src="sslfig.pdf" alt/></p><p>As one would expect in a diffusive network, the values on the vertices converge.</p><h4><a class="nav-anchor" id="Vector-variables-1" href="#Vector-variables-1">Vector variables</a></h4><p>In most cases, one is interested in problems with multiple variables on the vertices, one can deal with these problems by using the, compared to the previous more general, static_lines function:</p><pre><code class="language-julia">sl = static_lines(vertices!, edges!, g, dim_v, dim_e)</code></pre><p>In comparison to the scalar<em>static</em>lines function, here one also has to specify the dimension of the variables on each vertex and edge. The vectors dim<em>v and dim</em>e have entries for every vertex and edge in the graph, the value of the entry fixes the number of variables. As a simple example, let&#39;s again look at a problem with scalar variables. The functions vertices! and edges! are as before:</p><pre><code class="language-julia">dim_v = ones(Int32, length(vertices!))
dim_e = ones(Int32, length(edges!))
sl = static_lines(vertices!, edges!, g, dim_v, dim_e)</code></pre><p>Every entry of the dimension vectors is one, so the variables on each vertex and edge are 1-dimensional. Note that one has to specify the ones type as Integer.</p><p>The purpose of this function though is that we want treat higher dimensional problems. So let&#39;s look at an 2-dimensional problem.</p><pre><code class="language-julia">dim_v = 2 * ones(Int32, length(vertices!))
dim_e = 2 * ones(Int32, length(edges!))</code></pre><p>Now we fixed the dimension on every vertex and edge to 2, following from that the vertices! and edges! functions are also 2-dimensional. We again want to look at a diffusion problem, for that we have to change the vertices! function  due to a problem occuring with the sum function, namely that it is not able to deal with an Any-type empty set:</p><pre><code class="language-julia">function vertex!(dv, v, e_s, e_d, p, t)
    dv .= 0
    for e in e_s
        dv .-= e
    end
    for e in e_d
        dv .+= e
    end
    nothing
end

vertices! = [vertex! for vertex in vertices(g)]</code></pre><p>The edge! function stays the same. The arguments appearing in the functions are now all 2-dimensional, so in principle one could put for example non-diagonal matrices into play to establish an interaction between the different variables. As we did not do that here, what we expect is that we again get the same solution as before, but twice. To solve it, we now need to give the solver twice as many initial values x0, the pattern in the x vector goes [vertex1<em>variable1,vertex1</em>variable2,vertex2_variable1,...]:</p><pre><code class="language-julia">x0 = rand(20)
t = (0.,2.)
sl = static_lines(vertices!,edges!,g,dim_v,dim_e)
sl_prob = ODEProblem(ssl,x0,t)
sol = solve(ssl_prob)
plot(sol, legend = false)</code></pre><p>#figure</p><p>As we see, we get the solution of two independent diffusive networks. (Here one could put a more complex exmaple to showcase the functionality.)</p><h2><a class="nav-anchor" id="Dynamic-lines-1" href="#Dynamic-lines-1">Dynamic lines</a></h2><h4><a class="nav-anchor" id="Scalar-variables-2" href="#Scalar-variables-2">Scalar variables</a></h4><p>In general, currents do not solely depend on the vertex values they are connecting, but rather depend on its own value in some sort. For the case of scalar variables, we may use the function scalar<em>dynamic</em>lines:</p><pre><code class="language-julia">sdl = scalar_dynamic_lines(vertices!,edges!,g)</code></pre><p>The function arguments are now of the following form:</p><pre><code class="language-julia">vertices![n](dv[n],v[n],e_s[n],e_t[n],p,t)
edges![m](de[m],e[m],v_s,v_t,p,t)</code></pre><p>Compared to the static lines case with scalar variables, the vertices! function keeps its structure whereas the edges! function gets the new argument de[m]. This de[m] is the derivative of the edge value of edge m. Let&#39;s look at a simple example: A system with dynamic lines which decay to the usual diffusive system:</p><pre><code class="language-julia">vertices! = [(dv,v,l_s,l_t,p,t) -&gt; dv .= sum(e_s) .- sum(e_t) for vertex in vertices(g)]
edges! = [(de,e,v_s,v_t,p,t) -&gt; de .= 1000*(v_s .- v_t .- e) for edge in edges(g)]</code></pre><p>The change compared to the example for the static case should be clear; the factor of 1000 is just accelerating the decay. Again, we can quite simply solve this system. One has to be aware though that now one needs initial values for the vertices and the edges! These are given in the order x0 = [vertex1,vertex2,...,edge1,edge2,...]:</p><pre><code class="language-julia">g = barabasi_albert(10,5) #generates a graph with 10 vertices and 25 edges
x0 = rand(10 + 25)
t = (0.,2.)
sdl = scalar_dynamic_lines(vertices!,edges!,g)
sdl_prob = ODEProblem(sdl,x0,t)
sol = solve(sdl_prob)
plot(sol, legend = false , vars = 1:10)</code></pre><p>(Hier sollte ein Bild sein)</p><p>We see that the plot looks pretty much the same as for the static lines case. That is, because we included the factor of 1000 in the edges! function. Note that we added the argument vars to the plot function, this gives us solely the first 10 arguments of x which are the vertices. One could also get just the edge values by writing vars = 11:35 if one wishes.</p><h4><a class="nav-anchor" id="Vector-variables-2" href="#Vector-variables-2">Vector variables</a></h4><p>The step here is not a hard one, if one read through the previous Vector variables section. We can treat a system of vector variables with dynamic lines with the function dynamic_lines:</p><pre><code class="language-julia">dl = dynamic_lines(vertices!,edges!,g,dim_v,dim_e)</code></pre><p>One has to apply the same change to the vertices! function as for the static_lines function. Otherwise, everything should be clear. For the example, we take the decaying dynamic lines and just make two independent networks as for the Static lines:</p><pre><code class="language-julia">dim_v = 2 * ones(Int32, length(vertices!))
dim_e = 2 * ones(Int32, length(edges!))
g = barabasi_albert(10,5)

function vertex!(dv, v, e_s, e_d, p, t)
    dv .= 0
    for e in e_s
        dv .-= e
    end
    for e in e_d
        dv .+= e
    end
    nothing
end

vertices! = [vertex! for vertex in vertices(g)]
edges! = [(de,e,v_s,v_t,p,t) -&gt; de .= 1000*(v_s .- v_t .- e) for edge in edges(g)]

dl = dynamic_lines(vertices!,edges!,g,dim_v,dim_e)

x0 = rand(10 + 10 + 25 + 25)
t= (0.,2.)
dl_prob = ODEProblem(dl,x0,t)
sol= solve(dl_prob)
plot(sol, legend = false, vars = 1:20)</code></pre><p>(Bild)</p><p>We get the same pattern as for the scalar case, just twice.</p><footer><hr/><a class="next" href="Functions_and_Constructors/"><span class="direction">Next</span><span class="title">-</span></a></footer></article></body></html>
